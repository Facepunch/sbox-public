using System.Collections.Generic;
using System.Linq;

namespace Facepunch.InteropGen;

internal partial class NativeAotWriter : BaseWriter
{
    public NativeAotWriter(Definition definitions, string targetName) : base(definitions, targetName)
    {
    }

    public override void Generate()
    {
        WriteLine("// <auto-generated/>");
        WriteLine("using System;");
        WriteLine("using System.Runtime.InteropServices;");
        WriteLine();

        foreach (string ns in definitions.ManagedNamespace.Split("."))
        {
            StartBlock($"namespace {ns}");
        }

        StartBlock("public static unsafe partial class Interop");
        {
            // We will generate the main igen_... export here
            GenerateInitialize();

            // We will generate the stub methods here
            GenerateStubs();

            // We will generate helpers for callbacks here
            GenerateImports();
        }
        EndBlock();

        foreach (string ns in definitions.ManagedNamespace.Split("."))
        {
            EndBlock();
        }
    }

    private void GenerateInitialize()
    {
        var ident = definitions.Ident;
        var hash = definitions.Hash;
        IEnumerable<Function> imports = definitions.Classes.Where( x => x.Native == false ).Where( x => !ShouldSkip( x ) ).SelectMany( x => x.Functions );

        WriteLine( "/// <summary>" );
        WriteLine( "/// This is the entry point that the managed host uses to initialize the native library." );
        WriteLine( "/// </summary>" );
        WriteLine( $"[UnmanagedCallersOnly(EntryPoint = \"igen_{ident}\")]" );
        StartBlock( $"public static void igen_{ident}( int hash, void** managedFunctions, void** nativeFunctions, int* structSizes )" );
        {
            StartBlock( $"if ( hash != {hash} )" );
            {
                WriteLine( "Console.WriteLine( $\"Invalid hash in {ident}\" );" );
                WriteLine( "return;" );
            }
            EndBlock();

            WriteLine( "" );
            WriteLine( "int i = 0;" );
            
            // This is the C# equivalent of the nativeFunctions array population
            StartBlock();
            {
                WriteLine( $"nativeFunctions[i++] = (void*)&Debug_Error;" );

                foreach ( Class c in definitions.Classes.Where( x => x.Native == true ) )
                {
                    if ( ShouldSkip( c ) )
                    {
                        continue;
                    }

                    Class bc = c.BaseClass;

                    while ( bc != null )
                    {
                        Class subclass = bc;
                        // TODO: Add cast functions
                        // WriteLine( $"nativeFunctions[i++] = (void*)&Exports::From_{subclass.ManagedName}_To_{c.ManagedName};" );
                        // WriteLine( $"nativeFunctions[i++] = (void*)&Exports::To_{subclass.ManagedName}_From_{c.ManagedName};" );
                        bc = bc.BaseClass;
                    }

                    foreach ( Function f in c.Functions )
                    {
                        WriteLine( $"nativeFunctions[i++] = (void*)&Stubs.{f.MangledName};" );
                    }

                    foreach ( Variable f in c.Variables )
                    {
                        WriteLine( $"nativeFunctions[i++] = (void*)&Stubs._Get__{f.MangledName};" );
                        WriteLine( $"nativeFunctions[i++] = (void*)&Stubs._Set__{f.MangledName};" );
                    }
                }
            }
            EndBlock();
            
            WriteLine( "" );
            WriteLine( "// TODO: Struct size validation" );
            
            WriteLine( "" );
            WriteLine( "// TODO: Import managed functions" );

            WriteLine();
			WriteLine( "Console.WriteLine( \"\\n\\n\\n\\n\\n--------------- AOT INITIALIZED SUCCESSFULLY ----------------\\n\\n\\n\\n\\n\" );" );
        }
        EndBlock();
        WriteLine();

        WriteLine( "[UnmanagedCallersOnly(EntryPoint = \"Debug_Error\")]" );
        StartBlock( "public static void Debug_Error( byte* message )" );
        {
            WriteLine( "Console.WriteLine( $\"AOT:Debug_Error: {Marshal.PtrToStringAnsi((IntPtr)message)}\" );" );
        }
        EndBlock();
    }

    private void GenerateStubs()
    {
        StartBlock("public static class Stubs");
        {
            foreach (var c in definitions.Classes.Where(x => x.Native == true))
            {
                if (ShouldSkip(c)) continue;

                foreach (var f in c.Functions)
                {
                    // TODO: Correctly map arguments and return types
                    WriteLine($"[UnmanagedCallersOnly(EntryPoint = \"{f.MangledName}\")]");
                    StartBlock($"public static void {f.MangledName}()");
                    {
                        WriteLine($"Console.WriteLine(\"AOT STUB: {f.MangledName} NOT IMPLEMENTED\");");
                    }
                    EndBlock();
                    WriteLine();
                }

                foreach (var f in c.Variables)
                {
                    // Getter
                    WriteLine($"[UnmanagedCallersOnly(EntryPoint = \"_Get__{f.MangledName}\")]");
                    StartBlock($"public static void _Get__{f.MangledName}()");
                    {
                        WriteLine($"Console.WriteLine(\"AOT STUB: _Get__{f.MangledName} NOT IMPLEMENTED\");");
                    }
                    EndBlock();
                    WriteLine();

                    // Setter
                    WriteLine($"[UnmanagedCallersOnly(EntryPoint = \"_Set__{f.MangledName}\")]");
                    StartBlock($"public static void _Set__{f.MangledName}()");
                    {
                        WriteLine($"Console.WriteLine(\"AOT STUB: _Set__{f.MangledName} NOT IMPLEMENTED\");");
                    }
                    EndBlock();
                    WriteLine();
                }
            }
        }
        EndBlock();
    }

    private void GenerateImports()
    {
        // This will create delegates and fields for the function pointers
        // we receive from the managed host.
    }
}
